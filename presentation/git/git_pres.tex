\documentclass{article}
\usepackage{listings}
\usepackage{color}

\usepackage{tikz}
\usetikzlibrary{positioning,shapes,shadows,arrows}
 
\newenvironment{myitemize}{
\begin{itemize}
\setlength{\itemsep}{1pt}
\setlength{\parskip}{0pt}
\setlength{\parsep}{0pt}
}{\end{itemize}}

% For code style
\definecolor{blueviolet}{RGB}{138, 43, 226}
\def\cmd#1{\texttt{\textcolor{blueviolet}{#1}}}
\lstnewenvironment{git}{ 
  \lstset{
  language=bash,
  breaklines=true, 
  breakindent=0pt
}\tt \color{blueviolet}}{}



\begin{document}
% For diagram
\tikzstyle{commit}=[rectangle, draw=black, rounded corners, fill=green!40, drop
shadow, text centered, anchor=north]
\tikzstyle{branch}=[rectangle, draw=black, fill=red!30, drop
shadow, text centered, anchor=north, node distance = 7mm]
\tikzstyle{arrow}=[->, thick]

\title{Git}
\maketitle

\section{Note}
\subsection{Outline}
\begin{itemize}
\item Do you want to use Git ? Why ?
\item Git in 5 minutes (demo)
\item Advanceds git
\item Install Git : CERFACS or at home
\end{itemize}

\subsection{Slide structure (Basics)}
Commands \\
Tips section

\subsection{Why Git ?}
Centralized Version System depends on the server (not always reliable).
In Distributed VCS, a complete copy of the server is done locally.
Context : created by Linus Torvald for Linux kernel dev, after BitKeeper access
was revoked.
Qualities : fast, efficient, allows non-linear dev through branching

\subsection{Features}
\begin{myitemize}
\item Git stores snapshots instead of file differences. If
there was no changes, it stores a link to the previous version.
\item Most of the operations are local (no need for network + fast).
\item Data integrity : everything is checksum (SHA-1 hash). The hash is used for
storing (ex: git log)
\item Adds data : difficult to lose something
\item 3 states :  
 \begin{itemize}
  \item modified : changed, but not in database
  \item staged : changed, and ready to go in the next commit
  \item commited : in database
\end{itemize}
The folder are (resp.) :
 \begin{itemize}
  \item working directory (checkout of the project)
  \item staging area : a file with the info about the next commit
  \item git directory
\end{itemize}
\end{myitemize}


\section{Basic Git}
\subsection{Configuration :}
Here we configure the name, email, editor and the diff tool :\\
\cmd{git config --global user.name ``John Doe''}\\
\cmd{git config --global user.email johndoe@example.com}\\
\cmd{git config --global core.editor emacs}\\
\cmd{git config --global merge.tool vimdiff}\\
This can be checked with \cmd{ git config --list} 
or in \cmd{ .git/config}.

\subsection{Basics}
\cmd{ git init} : init the git repo\\
\cmd{ git add README} : add the file \\
\cmd{ git commit -m 'initial project version'} : commit with a message\\
\cmd{ git clone git://github.com/schacon/grit.git myfolder} : clone the git repo
into a local folder


\subsection{Recording changes}
\cmd{ git status}\\
\cmd{ git add }: untracked to unmodified/modified\\
\cmd{ git stage }: modified to staged\\
\cmd{ git commit }: staged to unmodified\\
\cmd{.gitignore :\\
\# a comment - this is ignored\\
*.a       \\
!lib.a    \\
/TODO     \\
build/    \\
doc/*.txt }

git diff : view exact changes
%
%Committing : git commit or git commit -m ``message''
%We can skip the staging : git commit -am ``message''
%Removing : just ``rm'' says ``\# Changed but not updated:'' so git rm
%Moving : git mv
%

\subsection{History}
\cmd{ git log} : commit message, author, date\\
\cmd{ git log -p} : show the diff \\
\cmd{ git log --stat} : number of modifications\\
\cmd{ git log --graph} : show branches\\
Graphical : \cmd{ gitk}

\subsection{Undoing}
\cmd{ git commit --amend} : add some file to a commit (staging area). Merge in
single commit\\
\cmd{ git reset HEAD myfile} : unstage\\
\cmd{ git checkout} : undo changes
WARNING : hard to lose something, but it must me commited.


\subsection{Remotes}
\cmd{ git remote -v} : show remote \\
Warning : can only pull from SSH url\\
\cmd{ git remote add [shortname] [url]} : add a remote \\
\cmd{ git fetch [shortname]} : fetch data without merging. Put it in local
branches. (TODO: check that) \\
\cmd{ git pull [shortname]} = git fetch \&\& git merge\\
\cmd{ git push remote branch} : push to the remote. Example : git push origin
master\\
\cmd{ git remote show} : show some informations about the remote
\cmd{ git remote rm }\cmd{ git remote rename }\\
{\it Tip : if you don't have the permissions to update branch, it's easiest to push
your local branch directly to the remote, instead of merging to the master.}

\subsection{Tags}
\cmd{ git tag -a v7.2 -m "This is the version 7.2"}: tag with a number and
message \\
\cmd{ git tag} : show tags\\
\cmd{ git show v7.2} : show info at version\\
\cmd{ git tag -s v7.2 -m "This is the version 7.2"}: tag with a GPG signature\\
\cmd{ git tag v7.2}: create lightweight tag (only checksum)\\
\cmd{ git tag -v v7.2}: verify tag\\
\cmd{ git tag -a v7.2 7epb61}: tag at the commit whose checksum is 7epb61 \\
Warning : you have to push you tags ! \cmd{ git push origin v7.2} or 
\cmd{ git push origin --tags} for all

\subsection{Tips}
There is a bash script for completion in the source code of git.
\cmd{ source ~/.git-completion.bash}

Aliases can be created : \cmd{ git config --global alias.co checkout}


\section{Advanced}
\subsection{Branches}
Why is it important ? Lightweight and fast.

\subsubsection{Basics}
Commit object = pointer to the snapshot, author, messages and pointer to the
previous commits (2 if merge).
A snapshot contains a blob (=version) for each file.

A branch is just a pointer to a commit. HEAD is a pointer to the current branch.
\begin{figure}[h]
  \begin{tikzpicture}[transform shape,font=\scriptsize,scale=1.9]
  \node (C1)[commit] {C1};
  \node (C2)[commit,right of=C1] {C2};
  \node (C3)[commit,below of=C2] {C3};
  \node (master)[branch,above of=C2] {master};
  \node (donkey)[branch,below of=C3] {donkey};
  \node (head)[branch,above of=master] {HEAD};
  \draw[arrow] (C2) to (C1);
  \draw[arrow] (C3) to (C1);
  \draw[arrow] (master) to (C2);
  \draw[arrow] (donkey) to (C3);
  \draw[arrow] (head) to (master);
\end{tikzpicture}
\end{figure}

Easy, right ?
\cmd{ git branch monkey} : creates a branch \\
\cmd{ git checkout monkey} : switch to the branch \\
\cmd{ git checkout -b monkey} : both of the above\\

\paragraph{Merging}
\cmd{ git checkout master}\cmd{ git checkout monkey} : merge to master\\
\cmd{ git branch -d monkey} : delete the branch. Don't worry, removes only a
pointer !\\

\paragraph{Conflicts} ~\\
\begin{git}
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
\end{git}
Don't panic !
\begin{git}
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
  please contact us at support@github.com
  </div>
>>>>>>> iss53:index.html
\end{git}
Simply remove the lines. Git cannot do that for you.
\cmd{ git mergetool} for a visual merging tool.

Check everything has been merged : \cmd{ git status}, and \cmd{ git commit}
(default message).
{\it Tip : with git merge, it will automatically commit. Use the --no-commit
option if you don't want to}

\paragraph{Management}
\cmd{ git branch} : list branch, with * on the current \\
\cmd{ git branch -v} : list branch with last commit \\
\cmd{ git branch --merged} : list branch with last commit \\

\subsection{Workflow}
Long-term branches : differents branch for stability. Ex (Debian) : \cmd{stable},\cmd{testing},\cmd{unstable}
Short-term branches : for testing ideas. This is only local.

\subsection{Remote branches}
Warning : source of confusion.\\
\paragraph{What happens when I clone ?} Git create an origin remote and pull the master. So
we have origin/master copied locally. However, we will work on the master branch
locally (the other will not be modified until the next push).\\
Explains the difference between fetch and pull : it creates a divergence.\\
What happens if someone commit between my git pull and my git push ?\\
You should always pull (git should say so) before pushing.\\
AND you should always check the log before that.

\paragraph{Tracking branch}
Cloning creates a master branch which will track origin/master so git push will
work without arguments.\\
\cmd{git checkout --track origin/monkey} : will track monkey\\
\cmd{git checkout -b donkey origin/monkey} : idem but with another name.\\
\cmd{git push origin :monkey} : delete remote branch (! difficult to memorise)

\subsection{Rebase}
git merge performs a merge between the 2 latest snapshots. 
\cmd{git checkout donkey} and \cmd{git rebase master} will take all the changes
from donkey and apply it to master (starts from common ancestor and apply
successively)\\
\cmd{git rebase master donkey} has the same result

What for ? Cleaner history (looks like we have done everything sequentially).
Result is the same.
QUIZZ : what does the following command does ?\\
\cmd{git rebase --onto master waiting testing} : will apply changes of testing
on master, but only from the ancestor of waiting and testing

NEVER use rebase on commits already pushed ? \\
QUIZZ : why ?\\

\section{Working with others}
\subsection{Commit guidelines}
\begin{enumerate}
  \item Check for whitespaces errors : \cmd{git diff --check}
  \item Each commit should be about a specific change. Don't forget you can
    split your work into several commits ! More readable and easier for
    reverting.
  \item Format your commit message. Ideally, a short description on the first
    line, followed by a body.
\end{enumerate}

\begin{git}
commit a3347b988a338e95b7f3b11eda776ac0d7b84dd0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 25 09:02:03 2012 -0700

fmt-merge-message: add empty line between tag and signature verification

When adding the information from a tag, put an empty line between the message of the tag and the commented -out signature verification information.

At least for the kernel workflow, I often end up re-formatting the message that people send me in the tag data. In that situation, putting the tag message and the tag signature verification back-to-back then means that normal editor "reflow parapgraph" command will get confused and think that the signature is a continuation of the last message paragraph.

So I always end up having to first add an empty line, and then go back and reflow the last paragraph. Let's just do it in git directly.

The extra vertical space also makes the verification visually stand out more from the user-supplied message, so it looks a bit more readable to me too, but that may be just an odd personal preference.

Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
Signed-off-by: Junio C Hamano <gitster@pobox.com>
\end{git}
\subsection{Patches}
A patch is the differences you have added to the project.
\cmd{git format-patch -M origin/master} will create patches ready to be emailed.
One file will be create per commit. -M checks for rename\\
Better than diff as it contains commit messages.\\
Warning : copy/paste can lead to formatting issues. But you can configure Git.

\cmd{git apply mypatch.patch} : apply a patch generated by \cmd{git
diff}(everything or nothing strategy).\\
\cmd{git am mypatch.patch} : apply a patch generated by \cmd{git format-patch}

\subsection{Communicating}
\cmd{git archive master | gzip > myarchive.tar.gz} : create an archive\\
\cmd{git shortlog master} : create a summary of the commits

\section{Expert}

%\section{Must read}
%http://gitready.com/
%Note : git rebase is good for local change, but not if somebody pulled your tree
%:
%http://lwn.net/Articles/328436/
%
%\section{Error messages}
%Perhaps you should specify a branch such as ``master''
\end{document}
